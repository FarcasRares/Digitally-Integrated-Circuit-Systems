

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;

entity toplevel is
 Port ( clk:in STD_LOGIC;
        a_to_g: out STD_LOGIC_VECTOR(27 downto 0);
        dp:out STD_LOGIC);
end toplevel;

architecture Behavioral of toplevel is

component bcd7 is
    Port ( a : in STD_LOGIC_VECTOR (3 downto 0);
           a_to_g : out STD_LOGIC_VECTOR (6 downto 0);
           clk : in STD_LOGIC);
end component bcd7;

component fib is
    Port ( clk : in STD_LOGIC;
           f : out STD_LOGIC_VECTOR (13 downto 0);
           clr : in STD_LOGIC);
end component fib;
signal clk_div: std_logic;
signal cnt: std_logic_vector(27 downto 0):=x"0000000";
signal total: std_logic_vector(27 downto 0);
signal clr:std_logic;
signal outBCD1,outBCD2,outBCD3,outBCD4:std_logic_vector(6 downto 0);
signal outFIB:std_logic_vector(13 downto 0);
signal a:std_logic_vector(3 downto 0);
begin


process(clk,clr)
begin
    if clr ='1' then
    cnt<=x"0000000";
    elsif rising_edge(clk) then
    if cnt=x"2FAF07F" then
    cnt<= x"0000000";
    clk_div<='1';
    else 
    cnt<= cnt+1;
    clk_div<='0';
    end if;
    end if;
  --divizorul de frecventa, cu raport de divizare 50Mhz - 1   
    
end process;
generatorfib: fib port map(clk=>clk_div,clr=>clr,f=>outFIB);
U1: bcd7 port map(a(0)=>outFIB(0),
a(1)=>outFIB(1),
a(2)=>outFIB(2),
a(3)=>outFIB(3),
a_to_g=>outBCD1,
clk=>clk_div
);
U2: bcd7 port map(a(0)=>outFIB(4),
a(1)=>outFIB(5),
a(2)=>outFIB(6),
a(3)=>outFIB(7),
a_to_g=>outBCD2,
clk=>clk_div
);

U3: bcd7 port map(a(0)=>outFIB(8),
a(1)=>outFIB(9),
a(2)=>outFIB(10),
a(3)=>outFIB(11),
a_to_g=>outBCD3,
clk=>clk_div
);

U4: bcd7 port map(a(0)=>outFIB(12),
a(1)=>outFIB(13),
a(2)=>'0',
a(3)=>'0',
clk=>clk_div,
a_to_g=>outBCD4
);
total <= outBCD1 & outBCD2& outBCD3&outBCD4;


end Behavioral;
